const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require("discord.js");
const { useFunctions, useDB, useConfig } = require("@zibot/zihooks");
const animals = require("../../data/animals.json");
const { updateQuestProgress } = require("./quests");

const BATTLE_COOLDOWN = 25 * 1000; // 25 gi√¢y
const BATTLE_ENTRY_COST = 150; // Chi ph√≠ Zigold ƒë·ªÉ tham gia chi·∫øn ƒë·∫•u

const battleEmoji = "‚öîÔ∏è"; // Bi·ªÉu t∆∞·ª£ng chi·∫øn ƒë·∫•u
const zigoldEmoji = "ü™ô"; // Bi·ªÉu t∆∞·ª£ng ZiGold  
const sparkleEmoji = "‚ú®"; // Bi·ªÉu t∆∞·ª£ng l·∫•p l√°nh
const gemEmoji = "üíé"; // Bi·ªÉu t∆∞·ª£ng ƒë√° qu√Ω
const crownEmoji = "üëë"; // Bi·ªÉu t∆∞·ª£ng v∆∞∆°ng mi·ªán
const starEmoji = "‚≠ê"; // Bi·ªÉu t∆∞·ª£ng ng√¥i sao
const rocketEmoji = "üöÄ"; // Bi·ªÉu t∆∞·ª£ng t√™n l·ª≠a
const shieldEmoji = "üõ°Ô∏è"; // Bi·ªÉu t∆∞·ª£ng khi√™n
const swordEmoji = "‚öîÔ∏è"; // Bi·ªÉu t∆∞·ª£ng ki·∫øm

module.exports.data = {
        name: "battle",
        description: "Chi·∫øn ƒë·∫•u v·ªõi animals c·ªßa b·∫°n ƒë·ªÉ ki·∫øm Zigold v√† XP!",
        type: 1,
        options: [
                {
                        type: 6,
                        name: "opponent",
                        description: "Challenge m·ªôt user kh√°c",
                        required: false
                }
        ],
        integration_types: [0, 1], // ·ª®ng d·ª•ng m√°y ch·ªß + ·ª®ng d·ª•ng ng∆∞·ªùi d√πng  
        contexts: [0, 1, 2], // M√°y ch·ªß + Tin nh·∫Øn ri√™ng + K√™nh ri√™ng t∆∞
        dm_permission: true,
        nsfw: false,
};

module.exports.execute = async ({ interaction, lang }) => {
        try {
                const ZiRank = useFunctions().get("ZiRank");
                const DataBase = useDB();
                const config = useConfig();

                // Ki·ªÉm tra xem c∆° s·ªü d·ªØ li·ªáu v√† c√°c h√†m ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë√∫ng c√°ch
                if (!DataBase || !DataBase.ZiUser || !ZiRank) {
                        return await handleInitializationError(interaction, !DataBase);
                }

                const opponent = interaction.options?.getUser("opponent");
                
                if (opponent) {
                        // Chi·∫øn ƒë·∫•u Ng∆∞·ªùi v·ªõi Ng∆∞·ªùi
                        return await initiatePvPBattle(interaction, opponent, DataBase, ZiRank);
                } else {
                        // Chi·∫øn ƒë·∫•u Ng∆∞·ªùi v·ªõi M√°y (ch·ªëng l·∫°i AI)
                        return await initiatePvEBattle(interaction, DataBase, ZiRank);
                }

        } catch (error) {
                console.error("Error in battle command:", error);
                await handleCommandError(interaction, error);
        }
};

async function handleInitializationError(interaction, isDatabaseError) {
        const errorEmbed = new EmbedBuilder()
                .setTitle(`‚ö†Ô∏è ${sparkleEmoji} Kh·ªüi t·∫°o h·ªá th·ªëng`)
                .setColor("#FFD700")
                .setDescription(
                        isDatabaseError 
                        ? `üîÑ **Database ƒëang kh·ªüi t·∫°o...**\n\n${sparkleEmoji} Vui l√≤ng ƒë·ª£i v√†i gi√¢y r·ªìi th·ª≠ l·∫°i!`
                        : `üîÑ **H·ªá th·ªëng ZiRank ƒëang kh·ªüi t·∫°o...**\n\n${sparkleEmoji} Vui l√≤ng ƒë·ª£i v√†i gi√¢y r·ªìi th·ª≠ l·∫°i!`
                )
                .setFooter({ 
                        text: "H·ªá th·ªëng s·∫Ω s·∫µn s√†ng trong gi√¢y l√°t!", 
                        iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();
        
        return await interaction.reply({ embeds: [errorEmbed], flags: 64 });
}

async function initiatePvPBattle(interaction, opponent, DataBase, ZiRank) {
        // Check if challenging self
        if (opponent.id === interaction.user.id) {
                return await showCannotChallengeSelf(interaction);
        }

        // Check if opponent is bot
        if (opponent.bot) {
                return await showCannotChallengeBot(interaction);
        }

        // Get both users' data
        const [challengerData, opponentData] = await Promise.all([
                DataBase.ZiUser.findOne({ userID: interaction.user.id }),
                DataBase.ZiUser.findOne({ userID: opponent.id })
        ]);

        // Check if users have animals
        if (!challengerData?.huntStats || !hasValidTeam(challengerData.huntStats)) {
                return await showNoAnimalsError(interaction, true);
        }

        if (!opponentData?.huntStats || !hasValidTeam(opponentData.huntStats)) {
                return await showOpponentNoAnimalsError(interaction, opponent);
        }

        // Show PvP challenge
        await showPvPChallenge(interaction, opponent, challengerData, opponentData);
}

async function initiatePvEBattle(interaction, DataBase, ZiRank) {
        const userId = interaction.user.id;
        const now = new Date();

        // Get user data
        const userDB = await DataBase.ZiUser.findOne({ userID: userId });

        // Check cooldown
        const cooldownCheck = checkBattleCooldown(userDB, now);
        if (cooldownCheck.onCooldown) {
                return await showCooldownMessage(interaction, cooldownCheck);
        }

        // Check if user has animals
        if (!userDB?.huntStats || !hasValidTeam(userDB.huntStats)) {
                return await showNoAnimalsError(interaction, false);
        }

        // Check if user has enough Zigold
        if (!userDB || (userDB.coin || 0) < BATTLE_ENTRY_COST) {
                return await showInsufficientFunds(interaction, BATTLE_ENTRY_COST, userDB?.coin || 0);
        }

        // Simulate PvE battle
        const battleResult = simulatePvEBattle(userDB);
        
        // Update user data
        await updateUserBattle(DataBase, userId, now, battleResult, ZiRank, userDB);
        
        // Show battle result
        await showBattleResult(interaction, battleResult, userDB);
}

function checkBattleCooldown(userDB, now) {
        if (!userDB?.lastBattle) {
                return { onCooldown: false };
        }

        const lastBattle = new Date(userDB.lastBattle);
        const timeDiff = now.getTime() - lastBattle.getTime();
        
        if (timeDiff < BATTLE_COOLDOWN) {
                const timeLeft = BATTLE_COOLDOWN - timeDiff;
                const secondsLeft = Math.ceil(timeLeft / 1000);
                
                return {
                        onCooldown: true,
                        timeLeft: { seconds: secondsLeft },
                        totalTimeLeft: timeLeft
                };
        }
        
        return { onCooldown: false };
}

async function showCooldownMessage(interaction, cooldownCheck) {
        const { seconds } = cooldownCheck.timeLeft;
        
        const cooldownEmbed = new EmbedBuilder()
                .setTitle(`‚è∞ ${battleEmoji} Battle Cooldown ${sparkleEmoji}`)
                .setColor("#FF6B9D")
                .setDescription(`**${sparkleEmoji} B·∫°n ƒë√£ battle g·∫ßn ƒë√¢y!**\n\nüéØ Animals c·ªßa b·∫°n ƒëang ngh·ªâ ng∆°i ${gemEmoji}`)
                .addFields({
                        name: `‚è≥ ${sparkleEmoji} Th·ªùi gian c√≤n l·∫°i`,
                        value: `\`\`\`${seconds} gi√¢y\`\`\``,
                        inline: true
                })
                .setThumbnail(interaction.user.displayAvatarURL({ dynamic: true }))
                .setFooter({ 
                        text: `${battleEmoji} H√£y chu·∫©n b·ªã chi·∫øn thu·∫≠t cho battle ti·∫øp theo! ‚Ä¢ ZiBot Battle System`,
                        iconURL: interaction.client.user.displayAvatarURL()
                })
                .setTimestamp();

        return await interaction.reply({ embeds: [cooldownEmbed], flags: 64 });
}

function hasValidTeam(huntStats) {
        let totalAnimals = 0;
        for (const [animalKey, animalData] of Object.entries(huntStats)) {
                // animalKey format: "rarity_animalname" (e.g., "common_dog")
                if (animalData && animalData.count) {
                        totalAnimals += animalData.count || 0;
                }
        }
        return totalAnimals >= 1; // Need at least 1 animal
}

async function showNoAnimalsError(interaction, isChallenger) {
        const errorEmbed = new EmbedBuilder()
                .setTitle(`‚ùå ${gemEmoji} Kh√¥ng c√≥ animals!`)
                .setColor("#FF4757")
                .setDescription(`**${sparkleEmoji} ${isChallenger ? "B·∫°n" : "B·∫°n"} c·∫ßn √≠t nh·∫•t 1 animal ƒë·ªÉ battle!**\n\nüèπ S·ª≠ d·ª•ng \`/hunt\` ƒë·ªÉ b·∫Øt animals tr∆∞·ªõc!\n${rocketEmoji} H√£y t·∫°o ƒë·ªôi h√¨nh m·∫°nh m·∫Ω!`)
                .setFooter({ 
                        text: `${battleEmoji} Hunt animals ƒë·ªÉ b·∫Øt ƒë·∫ßu battle! ‚Ä¢ ZiBot Battle System`, 
                        iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();
                
        return await interaction.reply({ embeds: [errorEmbed], flags: 64 });
}

async function showOpponentNoAnimalsError(interaction, opponent) {
        const errorEmbed = new EmbedBuilder()
                .setTitle(`‚ùå ${gemEmoji} ƒê·ªëi th·ªß kh√¥ng c√≥ animals!`)
                .setColor("#FF4757")
                .setDescription(`**${sparkleEmoji} ${opponent.username} ch∆∞a c√≥ animals ƒë·ªÉ battle!**\n\nüèπ H·ªç c·∫ßn hunt animals tr∆∞·ªõc!\n${rocketEmoji} H√£y challenge ng∆∞·ªùi kh√°c ho·∫∑c battle PvE!`)
                .setFooter({ 
                        text: `${battleEmoji} T√¨m ƒë·ªëi th·ªß x·ª©ng t·∫ßm kh√°c! ‚Ä¢ ZiBot Battle System`, 
                        iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();
                
        return await interaction.reply({ embeds: [errorEmbed], flags: 64 });
}

async function showCannotChallengeSelf(interaction) {
        const errorEmbed = new EmbedBuilder()
                .setTitle(`‚ùå ${gemEmoji} Kh√¥ng th·ªÉ t·ª± battle!`)
                .setColor("#FF4757")
                .setDescription(`**${sparkleEmoji} B·∫°n kh√¥ng th·ªÉ challenge ch√≠nh m√¨nh!**\n\n${battleEmoji} S·ª≠ d·ª•ng \`\`\`text\n/battle\n\`\`\` kh√¥ng c√≥ opponent ƒë·ªÉ battle PvE!\n${rocketEmoji} Ho·∫∑c tag m·ªôt user kh√°c ƒë·ªÉ challenge!`)
                .setFooter({ 
                        text: `${battleEmoji} H√£y t√¨m ƒë·ªëi th·ªß x·ª©ng t·∫ßm! ‚Ä¢ ZiBot Battle System`, 
                        iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();
                
        return await interaction.reply({ embeds: [errorEmbed], flags: 64 });
}

async function showCannotChallengeBot(interaction) {
        const errorEmbed = new EmbedBuilder()
                .setTitle(`‚ùå ${gemEmoji} Kh√¥ng th·ªÉ challenge bot!`)
                .setColor("#FF4757")
                .setDescription(`**${sparkleEmoji} B·∫°n kh√¥ng th·ªÉ challenge bot!**\n\n${battleEmoji} S·ª≠ d·ª•ng \`\`\`text\n/battle\n\`\`\` ƒë·ªÉ battle PvE!\n${rocketEmoji} Ho·∫∑c challenge m·ªôt user th·∫≠t!`)
                .setFooter({ 
                        text: `${battleEmoji} H√£y challenge ƒë·ªëi th·ªß l√† con ng∆∞·ªùi! ‚Ä¢ ZiBot Battle System`, 
                        iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();
                
        return await interaction.reply({ embeds: [errorEmbed], flags: 64 });
}

async function showInsufficientFunds(interaction, battleCost, userCoin) {
        const errorEmbed = new EmbedBuilder()
                .setTitle(`‚ùå ${gemEmoji} Kh√¥ng ƒë·ªß Zigold!`)
                .setColor("#FF4757")
                .setDescription(`**Oops!** ${sparkleEmoji} B·∫°n c·∫ßn **${battleCost.toLocaleString()}** ${zigoldEmoji} Zigold ƒë·ªÉ battle!\n\nüí∞ **S·ªë d∆∞ hi·ªán t·∫°i:** ${userCoin.toLocaleString()} ${zigoldEmoji}\n\nüîÑ H√£y claim daily ho·∫∑c hunt ƒë·ªÉ ki·∫øm th√™m Zigold!`)
                .setFooter({ 
                        text: `${battleEmoji} S·ª≠ d·ª•ng /daily ƒë·ªÉ nh·∫≠n Zigold mi·ªÖn ph√≠!`, 
                        iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();
                
        return await interaction.reply({ embeds: [errorEmbed], flags: 64 });
}

function simulatePvEBattle(userDB) {
        // Get user's strongest animals
        const userTeam = buildUserTeam(userDB.huntStats);
        
        // Generate AI opponent based on user level
        const aiTeam = generateAIOpponent(userDB.level || 1);
        
        // Calculate team powers
        const userPower = calculateTeamPower(userTeam);
        const aiPower = calculateTeamPower(aiTeam);
        
        // Add some randomness (¬±20%)
        const userRoll = userPower * (0.8 + Math.random() * 0.4);
        const aiRoll = aiPower * (0.8 + Math.random() * 0.4);
        
        const userWins = userRoll > aiRoll;
        const powerRatio = userRoll / aiRoll;
        
        // Calculate rewards based on performance
        const baseZigold = BATTLE_ENTRY_COST;
        const baseXP = 50;
        
        if (userWins) {
                const winMultiplier = Math.min(powerRatio, 2.0); // Max 2x for overwhelming victory
                return {
                        victory: true,
                        zigoldReward: Math.floor(baseZigold * (1.5 + winMultiplier * 0.5)),
                        xpReward: Math.floor(baseXP * (1.2 + winMultiplier * 0.3)),
                        userTeam,
                        aiTeam,
                        userPower: Math.floor(userRoll),
                        aiPower: Math.floor(aiRoll),
                        battleCost: BATTLE_ENTRY_COST
                };
        } else {
                // Consolation rewards for losing
                return {
                        victory: false,
                        zigoldReward: Math.floor(baseZigold * 0.3), // 30% refund
                        xpReward: Math.floor(baseXP * 0.5), // 50% XP for effort
                        userTeam,
                        aiTeam,
                        userPower: Math.floor(userRoll),
                        aiPower: Math.floor(aiRoll),
                        battleCost: BATTLE_ENTRY_COST
                };
        }
}

function buildUserTeam(huntStats) {
        const team = [];
        
        // Prioritize by rarity and power
        const rarityOrder = ['legendary', 'epic', 'rare', 'uncommon', 'common'];
        
        // Convert huntStats to organized structure for processing
        const organizedAnimals = {};
        for (const [animalKey, animalData] of Object.entries(huntStats)) {
                if (!animalData || !animalData.count || animalData.count <= 0) continue;
                
                // Parse rarity and animal name from key (format: "rarity_animalname")
                const parts = animalKey.split('_');
                if (parts.length < 2) continue;
                
                const rarity = parts[0];
                const animalName = parts.slice(1).join('_'); // Handle animal names with underscores
                
                if (!organizedAnimals[rarity]) {
                        organizedAnimals[rarity] = {};
                }
                organizedAnimals[rarity][animalName] = animalData.count;
        }
        
        // Build team using organized data
        for (const rarity of rarityOrder) {
                if (!organizedAnimals[rarity]) continue;
                
                for (const [animalName, count] of Object.entries(organizedAnimals[rarity])) {
                        if (count > 0) {
                                const animalData = animals[rarity]?.find(a => a.name === animalName);
                                if (animalData) {
                                        team.push({
                                                ...animalData,
                                                rarity,
                                                count: Math.min(count, 3) // Max 3 of same animal in battle
                                        });
                                }
                        }
                        if (team.length >= 5) break; // Max team size
                }
                if (team.length >= 5) break;
        }
        
        return team.slice(0, 5); // Ensure max 5 animals
}

function generateAIOpponent(userLevel) {
        const team = [];
        const teamSize = Math.min(3 + Math.floor(userLevel / 20), 5); // Scale with user level
        
        // Generate AI team based on user level
        for (let i = 0; i < teamSize; i++) {
                const rarity = selectAIAnimalRarity(userLevel);
                const availableAnimals = animals[rarity];
                const selectedAnimal = availableAnimals[Math.floor(Math.random() * availableAnimals.length)];
                
                team.push({
                        ...selectedAnimal,
                        rarity,
                        count: 1
                });
        }
        
        return team;
}

function selectAIAnimalRarity(userLevel) {
        // AI gets better animals as user level increases
        const levelBonus = Math.min(userLevel * 0.01, 0.3); // Max 30% bonus
        
        const adjustedChances = {
                'common': Math.max(0.4 - levelBonus, 0.1),
                'uncommon': Math.max(0.3 - levelBonus * 0.5, 0.2),
                'rare': Math.min(0.2 + levelBonus * 0.5, 0.4),
                'epic': Math.min(0.08 + levelBonus * 0.8, 0.2),
                'legendary': Math.min(0.02 + levelBonus, 0.1)
        };
        
        const rand = Math.random();
        let cumulative = 0;
        
        for (const [rarity, chance] of Object.entries(adjustedChances)) {
                cumulative += chance;
                if (rand <= cumulative) {
                        return rarity;
                }
        }
        
        return 'common';
}

function calculateTeamPower(team) {
        return team.reduce((total, animal) => {
                const rarityMultiplier = {
                        'common': 1.0,
                        'uncommon': 1.5,
                        'rare': 2.5,
                        'epic': 4.0,
                        'legendary': 7.0
                }[animal.rarity] || 1.0;
                
                return total + (animal.value * rarityMultiplier * animal.count);
        }, 0);
}

async function updateUserBattle(DataBase, userId, now, battleResult, ZiRank, oldUserData) {
        try {
                // Update user data
                await DataBase.ZiUser.findOneAndUpdate(
                        { userID: userId },
                        {
                                $set: { 
                                        lastBattle: now,
                                        name: userId
                                },
                                $inc: { 
                                        coin: battleResult.zigoldReward - battleResult.battleCost,
                                        [`battleStats.${battleResult.victory ? 'wins' : 'losses'}`]: 1,
                                        'battleStats.total': 1
                                },
                                $setOnInsert: {
                                        level: 1,
                                        xp: 1,
                                        volume: 100,
                                        color: "Random"
                                }
                        },
                        { 
                                new: true, 
                                upsert: true,
                                setDefaultsOnInsert: true
                        }
                );

                // Update quest progress for battle wins
                if (battleResult.victory) {
                        await updateQuestProgress(DataBase, userId, 'battle', 1);
                }
                
                // Add XP through ZiRank
                await ZiRank.execute({ 
                        user: { id: userId }, 
                        XpADD: battleResult.xpReward,
                        CoinADD: 0
                });
                
        } catch (error) {
                console.error("Database update error:", error);
        }
}

async function showBattleResult(interaction, battleResult, userDB) {
        const userName = interaction.member?.displayName ?? interaction.user.globalName ?? interaction.user.username;
        
        // Determine embed color based on result
        const resultColor = battleResult.victory ? "#2ECC71" : "#E74C3C";
        const resultIcon = battleResult.victory ? "üéâ" : "üíî";
        const resultTitle = battleResult.victory ? "VICTORY!" : "DEFEAT";
        
        // Main embed
        const battleEmbed = new EmbedBuilder()
                .setTitle(`${battleEmoji} ${gemEmoji} Battle Complete! ${resultIcon}`)
                .setColor(resultColor)
                .setDescription(`**${crownEmoji} ${userName}** ${battleResult.victory ? "ƒë√£ chi·∫øn th·∫Øng" : "ƒë√£ thua cu·ªôc"}!\n\n${rocketEmoji} *${resultTitle}*`)
                .setThumbnail(interaction.user.displayAvatarURL({ dynamic: true }));

        // Battle details
        const powerComparison = `${swordEmoji} **Your Power:** \`${battleResult.userPower.toLocaleString()}\`\n${shieldEmoji} **Enemy Power:** \`${battleResult.aiPower.toLocaleString()}\``;
        battleEmbed.addFields({
                name: `${sparkleEmoji} Battle Analysis`,
                value: powerComparison,
                inline: false
        });

        // Rewards
        const rewardsText = `${zigoldEmoji} **Zigold:** \`${battleResult.zigoldReward > 0 ? '+' : ''}${(battleResult.zigoldReward - battleResult.battleCost).toLocaleString()}\` (Entry: -${battleResult.battleCost.toLocaleString()})\n${starEmoji} **XP Gained:** \`+${battleResult.xpReward}\``;
        battleEmbed.addFields({
                name: `üí∞ ${gemEmoji} Battle Rewards`,
                value: rewardsText,
                inline: true
        });

        // Team display (your team)
        const yourTeamText = battleResult.userTeam.slice(0, 3).map(animal => 
                `${animal.emoji} **${animal.name}** ${animal.count > 1 ? `x${animal.count}` : ''}`
        ).join('\n') || 'No team data';
        
        battleEmbed.addFields({
                name: `${swordEmoji} Your Team`,
                value: yourTeamText,
                inline: true
        });

        // Enemy team display
        const enemyTeamText = battleResult.aiTeam.slice(0, 3).map(animal => 
                `${animal.emoji} **${animal.name}**`
        ).join('\n') || 'No enemy data';
        
        battleEmbed.addFields({
                name: `${shieldEmoji} Enemy Team`,
                value: enemyTeamText,
                inline: true
        });

        // Battle stats
        const battleStats = userDB.battleStats || { wins: 0, losses: 0, total: 0 };
        const winRate = battleStats.total > 0 ? Math.round((battleStats.wins / battleStats.total) * 100) : 0;
        const statsText = `üèÜ **Wins:** \`${battleStats.wins + (battleResult.victory ? 1 : 0)}\`\nüíÄ **Losses:** \`${battleStats.losses + (battleResult.victory ? 0 : 1)}\`\nüìä **Win Rate:** \`${winRate}%\``;
        
        battleEmbed.addFields({
                name: `üìä ${crownEmoji} Battle Stats`,
                value: statsText,
                inline: false
        });

        // Footer with encouragement
        const encouragements = {
                victory: [
                        "Excellent strategy!",
                        "Your animals fought bravely!",
                        "Victory tastes sweet!",
                        "A well-deserved win!",
                        "Champion in the making!"
                ],
                defeat: [
                        "Better luck next time!",
                        "Learn from this battle!",
                        "Train harder for victory!",
                        "Every defeat makes you stronger!",
                        "Comeback time!"
                ]
        };
        
        const messages = encouragements[battleResult.victory ? 'victory' : 'defeat'];
        const randomMessage = messages[Math.floor(Math.random() * messages.length)];
        
        battleEmbed.setFooter({
                text: `${battleEmoji} ${randomMessage} ‚Ä¢ ZiBot Battle System`,
                iconURL: interaction.client.user.displayAvatarURL()
        });
        
        battleEmbed.setTimestamp();

        // Action buttons
        const row = new ActionRowBuilder()
                .addComponents(
                        new ButtonBuilder()
                                .setCustomId('B_battleAgain')
                                .setLabel('Battle Again')
                                .setStyle(ButtonStyle.Success)
                                .setEmoji(battleEmoji),
                        new ButtonBuilder()
                                .setCustomId('B_viewTeam')
                                .setLabel('View Team')
                                .setStyle(ButtonStyle.Secondary)
                                .setEmoji('üë•'),
                        new ButtonBuilder()
                                .setCustomId('B_huntMore')
                                .setLabel('Hunt More')
                                .setStyle(ButtonStyle.Primary)
                                .setEmoji('üèπ')
                );

        await interaction.reply({ embeds: [battleEmbed], components: [row] });
}

async function showPvPChallenge(interaction, opponent, challengerData, opponentData) {
        // For now, just show that PvP is coming soon
        const pvpEmbed = new EmbedBuilder()
                .setTitle(`${battleEmoji} ${gemEmoji} PvP Challenge`)
                .setColor("#9B59B6")
                .setDescription(`**${sparkleEmoji} PvP battles ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn!**\n\nüöß **Coming Soon:**\n‚Ä¢ Player vs Player battles\n‚Ä¢ Tournament system\n‚Ä¢ Betting system\n‚Ä¢ Guild wars\n\n${battleEmoji} Hi·ªán t·∫°i h√£y s·ª≠ d·ª•ng \`/battle\` ƒë·ªÉ battle PvE!`)
                .setFooter({ 
                        text: `${sparkleEmoji} PvP system s·∫Ω c√≥ trong update ti·∫øp theo! ‚Ä¢ ZiBot Battle System`, 
                        iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();
                
        return await interaction.reply({ embeds: [pvpEmbed], flags: 64 });
}

async function handleCommandError(interaction, error) {
        const errorEmbed = new EmbedBuilder()
                .setTitle(`‚ùå ${gemEmoji} L·ªói h·ªá th·ªëng`)
                .setColor("#FF4757")
                .setDescription(`**Oops!** ${sparkleEmoji} ƒê√£ x·∫£y ra l·ªói khi battle.\n\nüîÑ **Vui l√≤ng th·ª≠ l·∫°i sau** ho·∫∑c li√™n h·ªá admin n·∫øu v·∫•n ƒë·ªÅ v·∫´n ti·∫øp t·ª•c!\n\n${rocketEmoji} *Ch√∫ng t√¥i ƒëang l√†m vi·ªác ƒë·ªÉ kh·∫Øc ph·ª•c s·ª± c·ªë.*`)
                .addFields({
                        name: "üõ†Ô∏è H∆∞·ªõng d·∫´n kh·∫Øc ph·ª•c",
                        value: `‚Ä¢ ƒê·ª£i v√†i gi√¢y r·ªìi th·ª≠ l·∫°i\n‚Ä¢ Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng\n‚Ä¢ Li√™n h·ªá admin n·∫øu c·∫ßn h·ªó tr·ª£`,
                        inline: false
                })
                .setFooter({ 
                        text: `${sparkleEmoji} ZiBot lu√¥n c·ªë g·∫Øng mang ƒë·∫øn tr·∫£i nghi·ªám t·ªët nh·∫•t!`, 
                        iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();
        
        const errorResponse = { embeds: [errorEmbed], flags: 64 };
        
        if (interaction.replied || interaction.deferred) {
                await interaction.followUp(errorResponse).catch(() => {});
        } else {
                await interaction.reply(errorResponse).catch(() => {});
        }
}