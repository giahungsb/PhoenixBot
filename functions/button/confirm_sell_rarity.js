const { EmbedBuilder } = require("discord.js");
const { useFunctions, useDB } = require("@zibot/zihooks");
const animals = require("../../data/animals.json");

const sellEmoji = "üí∞"; // Sell emoji
const zigoldEmoji = "ü™ô"; // ZiGold emoji
const sparkleEmoji = "‚ú®"; // Sparkle emoji
const gemEmoji = "üíé"; // Gem emoji
const starEmoji = "‚≠ê"; // Star emoji

module.exports.data = {
    name: "confirm_sell_rarity",
    type: "button",
};

/**
 * @param { object } button - object button
 * @param { import("discord.js").ButtonInteraction } button.interaction - button interaction
 * @param { import("../../lang/vi.js") } button.lang - language
 */
module.exports.execute = async ({ interaction, lang }) => {
    try {
        const ZiRank = useFunctions().get("ZiRank");
        const DataBase = useDB();

        // Check if database and functions are properly initialized
        if (!DataBase || !DataBase.ZiUser || !ZiRank) {
            return await handleInitializationError(interaction, !DataBase);
        }

        // Extract rarity from embed title
        const embedTitle = interaction.message.embeds[0]?.title || "";
        const rarityMatch = embedTitle.match(/(common|uncommon|rare|epic|legendary)/i);
        const rarity = rarityMatch ? rarityMatch[1].toLowerCase() : null;
        
        if (!rarity) {
            const errorEmbed = new EmbedBuilder()
                .setTitle("‚ùå L·ªói")
                .setColor("#FF4757")
                .setDescription("Kh√¥ng th·ªÉ x√°c ƒë·ªãnh rarity ƒë·ªÉ b√°n!");
            return await interaction.update({ 
                embeds: [errorEmbed], 
                components: [] 
            });
        }

        // Immediately disable the button to prevent double-clicks
        const processingEmbed = new EmbedBuilder()
            .setTitle(`${sparkleEmoji} Processing ${rarity.charAt(0).toUpperCase() + rarity.slice(1)} Sale...`)
            .setColor("#FFD700")
            .setDescription(`üîÑ **ƒêang x·ª≠ l√Ω vi·ªác b√°n ${rarity} animals...**\n\n‚è≥ Vui l√≤ng ƒë·ª£i trong gi√¢y l√°t!`)
            .setFooter({ 
                text: "ƒêang th·ª±c hi·ªán giao d·ªãch an to√†n...", 
                iconURL: interaction.client.user.displayAvatarURL() 
            })
            .setTimestamp();

        await interaction.update({ 
            embeds: [processingEmbed], 
            components: [] // Remove all buttons immediately
        });

        const userId = interaction.user.id;

        // Perform atomic sale operation
        const saleResult = await performAtomicSaleRarity(DataBase, userId, rarity);
        
        if (!saleResult.success) {
            const errorEmbed = new EmbedBuilder()
                .setTitle("‚ùå " + saleResult.title)
                .setColor("#FF4757")
                .setDescription(saleResult.message)
                .setFooter({ 
                    text: saleResult.footer, 
                    iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();
            
            return await interaction.editReply({ 
                embeds: [errorEmbed], 
                components: [] 
            });
        }

        // Apply XP bonus through ZiRank (10% of ZiGold earned as XP)
        const xpReward = Math.floor(saleResult.totalValue * 0.1);
        try {
            await ZiRank.execute({ 
                user: interaction.user, 
                XpADD: xpReward,
                CoinADD: 0 // We already handled coins in the atomic update
            });
        } catch (rankError) {
            console.error("ZiRank error in sell:", rankError);
            // Continue with sale success even if ZiRank fails
        }

        // Rarity emojis and colors
        const rarityEmojis = {
            legendary: "üíé",
            epic: "üîÆ", 
            rare: "‚ö°",
            uncommon: "üåü",
            common: "‚ö™"
        };

        const rarityColors = {
            legendary: "#FFD700",
            epic: "#9C27B0",
            rare: "#2196F3",
            uncommon: "#4CAF50",
            common: "#9E9E9E"
        };

        // Create success embed
        const successEmbed = new EmbedBuilder()
            .setTitle(`${sellEmoji} ${rarityEmojis[rarity]} ${rarity.charAt(0).toUpperCase() + rarity.slice(1)} Sale Complete! ${sparkleEmoji}`)
            .setColor(rarityColors[rarity])
            .setThumbnail(interaction.user.displayAvatarURL({ dynamic: true }))
            .setDescription(`**Great sale!** You sold all your ${rarity} animals for an excellent price!`)
            .addFields(
                {
                    name: `${sellEmoji} Sale Summary`,
                    value: `ü¶Å **${saleResult.totalAnimals}** ${rarity} animals\n${zigoldEmoji} **+${saleResult.totalValue.toLocaleString()}** ZiGold`,
                    inline: true
                },
                {
                    name: `${starEmoji} Rewards`,
                    value: `${starEmoji} **+${xpReward}** XP\nüéØ **Rarity Cleared!**`,
                    inline: true
                },
                {
                    name: `${sparkleEmoji} New Balance`,
                    value: `${zigoldEmoji} **${saleResult.newBalance.toLocaleString()}** ZiGold`,
                    inline: true
                }
            )
            .setFooter({ 
                text: `üí∞ Excellent ${rarity} collection sale! ‚Ä¢ ZiBot Market`,
                iconURL: interaction.client.user.displayAvatarURL() 
            })
            .setTimestamp();

        // Add details of what was sold (if not too many)
        if (saleResult.animalsSold && saleResult.animalsSold.length <= 6) {
            let soldDetails = "";
            for (const animal of saleResult.animalsSold) {
                soldDetails += `${animal.emoji} **${animal.count}x** ${animal.name} - ${animal.value.toLocaleString()} ${zigoldEmoji}\n`;
            }
            successEmbed.addFields({
                name: `${sparkleEmoji} Animals Sold`,
                value: soldDetails,
                inline: false
            });
        }

        // Add achievement message based on rarity and value
        let achievementText = "";
        if (rarity === "legendary" && saleResult.totalValue >= 30000) {
            achievementText = `**üíé LEGENDARY COLLECTOR!** - Massive legendary sale!`;
        } else if (rarity === "epic" && saleResult.totalValue >= 15000) {
            achievementText = `**üîÆ EPIC TRADER!** - Amazing epic collection!`;
        } else if (rarity === "rare" && saleResult.totalValue >= 5000) {
            achievementText = `**‚ö° RARE HUNTER!** - Impressive rare collection!`;
        } else if (saleResult.totalValue >= 1000) {
            achievementText = `**‚≠ê SMART TRADER!** - Great collection sale!`;
        }

        if (achievementText) {
            successEmbed.addFields({
                name: `${gemEmoji} Achievement`,
                value: achievementText,
                inline: false
            });
        }

        await interaction.editReply({ embeds: [successEmbed] });

    } catch (error) {
        console.error("Error in confirm_sell_rarity:", error);
        await handleButtonError(interaction, error);
    }
};

// Atomic sale operation for specific rarity
async function performAtomicSaleRarity(DataBase, userId, rarity) {
    try {
        // Generate unique transaction ID for this operation
        const transactionId = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // First, get current user data to compute sale value
        const userDB = await DataBase.ZiUser.findOne({ userID: userId });
        
        if (!userDB || !userDB.huntStats || Object.keys(userDB.huntStats).length === 0) {
            return {
                success: false,
                title: "Kh√¥ng c√≥ animals!",
                message: `B·∫°n kh√¥ng c√≤n animals **${rarity}** n√†o ƒë·ªÉ b√°n!`,
                footer: "Animals ƒë√£ ƒë∆∞·ª£c b√°n ho·∫∑c chuy·ªÉn ƒëi!"
            };
        }

        // Calculate what should be sold for this rarity
        const huntStats = userDB.huntStats || {};
        let totalAnimals = 0;
        let totalValue = 0;
        const animalEntries = [];
        const animalsSold = [];

        for (const [huntKey, huntData] of Object.entries(huntStats)) {
            if (!huntData || !huntData.count || huntData.count <= 0) continue;
            
            const parts = huntKey.split('_');
            const huntRarity = parts[0];
            const animalName = parts.slice(1).join('_');
            
            if (huntRarity !== rarity) continue;
            if (!animals[rarity]) continue;
            
            const animalData = animals[rarity].find(a => a.name === animalName);
            if (animalData) {
                const count = huntData.count;
                const value = animalData.value * count;
                
                totalAnimals += count;
                totalValue += value;
                animalEntries.push({
                    huntKey,
                    count,
                    value
                });
                animalsSold.push({
                    name: animalData.name,
                    emoji: animalData.emoji,
                    count: count,
                    value: value
                });
            }
        }

        if (totalAnimals === 0) {
            return {
                success: false,
                title: "Kh√¥ng c√≥ animals!",
                message: `B·∫°n kh√¥ng c√≤n animals **${rarity}** n√†o ƒë·ªÉ b√°n!`,
                footer: "Animals ƒë√£ ƒë∆∞·ª£c b√°n r·ªìi!"
            };
        }

        // Build atomic update operations - set all animal counts to 0 for this rarity
        const setOperations = {};
        for (const entry of animalEntries) {
            setOperations[`huntStats.${entry.huntKey}.count`] = 0;
        }

        // Add transaction tracking to prevent duplicate processing
        setOperations[`lastSaleTransaction`] = transactionId;

        // Build condition that ensures inventory hasn't changed since we calculated totals
        const inventoryConditions = { 
            userID: userId,
            $or: [
                { lastSaleTransaction: { $exists: false } },
                { lastSaleTransaction: { $ne: transactionId } }
            ]
        };
        
        // Add conditions to verify animal counts are still as expected
        for (const entry of animalEntries) {
            inventoryConditions[`huntStats.${entry.huntKey}.count`] = { $gte: entry.count };
        }

        // Perform atomic update - only proceed if inventory state matches expectations
        const updateResult = await DataBase.ZiUser.findOneAndUpdate(
            inventoryConditions,
            {
                $inc: {
                    coin: totalValue,
                    totalAnimals: -totalAnimals
                },
                $set: setOperations
            },
            { new: true }
        );

        if (!updateResult) {
            return {
                success: false,
                title: "Giao d·ªãch ƒë√£ x·ª≠ l√Ω!",
                message: "Giao d·ªãch n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω r·ªìi ho·∫∑c inventory ƒë√£ thay ƒë·ªïi!",
                footer: "Vui l√≤ng ki·ªÉm tra l·∫°i collection c·ªßa b·∫°n!"
            };
        }

        return {
            success: true,
            totalAnimals,
            totalValue,
            newBalance: updateResult.coin,
            animalsSold,
            transactionId
        };

    } catch (error) {
        console.error("Atomic sale rarity operation error:", error);
        return {
            success: false,
            title: "L·ªói h·ªá th·ªëng!",
            message: "C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω giao d·ªãch. Vui l√≤ng th·ª≠ l·∫°i!",
            footer: "N·∫øu v·∫•n ƒë·ªÅ ti·∫øp t·ª•c, h√£y li√™n h·ªá admin!"
        };
    }
}

async function handleInitializationError(interaction, isDatabaseError) {
    const errorEmbed = new EmbedBuilder()
        .setTitle(`‚ö†Ô∏è ${sparkleEmoji} Kh·ªüi t·∫°o h·ªá th·ªëng`)
        .setColor("#FFD700")
        .setDescription(
            isDatabaseError 
            ? `üîÑ **Database ƒëang kh·ªüi t·∫°o...**\n\n${sparkleEmoji} Vui l√≤ng ƒë·ª£i v√†i gi√¢y r·ªìi th·ª≠ l·∫°i!`
            : `üîÑ **H·ªá th·ªëng ZiRank ƒëang kh·ªüi t·∫°o...**\n\n${sparkleEmoji} Vui l√≤ng ƒë·ª£i v√†i gi√¢y r·ªìi th·ª≠ l·∫°i!`
        )
        .setFooter({ 
            text: "H·ªá th·ªëng s·∫Ω s·∫µ s√†ng trong gi√¢y l√°t!", 
            iconURL: interaction.client.user.displayAvatarURL() 
        })
        .setTimestamp();
    
    return await interaction.update({ 
        embeds: [errorEmbed], 
        components: [] 
    });
}

async function handleButtonError(interaction, error) {
    console.error("Confirm sell rarity button error:", error);
    const errorEmbed = new EmbedBuilder()
        .setTitle("‚ùå L·ªói")
        .setColor("#FF0000")
        .setDescription("C√≥ l·ªói x·∫£y ra khi b√°n animals. Vui l√≤ng th·ª≠ l·∫°i!");
    
    try {
        if (interaction.replied || interaction.deferred) {
            return await interaction.editReply({ embeds: [errorEmbed], components: [] });
        } else {
            return await interaction.update({ embeds: [errorEmbed], components: [] });
        }
    } catch (updateError) {
        console.error("Failed to update interaction after error:", updateError);
    }
}