const { EmbedBuilder } = require("discord.js");
const { useFunctions, useDB } = require("@zibot/zihooks");
const animals = require("../../data/animals.json");

const sellEmoji = "üí∞"; // Sell emoji
const zigoldEmoji = "ü™ô"; // ZiGold emoji
const sparkleEmoji = "‚ú®"; // Sparkle emoji
const gemEmoji = "üíé"; // Gem emoji
const starEmoji = "‚≠ê"; // Star emoji

module.exports.data = {
    name: "confirm_sell_all",
    type: "button",
};

/**
 * @param { object } button - object button
 * @param { import("discord.js").ButtonInteraction } button.interaction - button interaction
 * @param { import("../../lang/vi.js") } button.lang - language
 */
module.exports.execute = async ({ interaction, lang }) => {
    try {
        const ZiRank = useFunctions().get("ZiRank");
        const DataBase = useDB();

        // Check if database and functions are properly initialized
        if (!DataBase || !DataBase.ZiUser || !ZiRank) {
            return await handleInitializationError(interaction, !DataBase);
        }

        // User verification is handled by Discord automatically for interactions

        // Immediately disable the button to prevent double-clicks
        const processingEmbed = new EmbedBuilder()
            .setTitle(`${sparkleEmoji} Processing Sale...`)
            .setColor("#FFD700")
            .setDescription(`üîÑ **ƒêang x·ª≠ l√Ω vi·ªác b√°n animals...**\n\n‚è≥ Vui l√≤ng ƒë·ª£i trong gi√¢y l√°t!`)
            .setFooter({ 
                text: "ƒêang th·ª±c hi·ªán giao d·ªãch an to√†n...", 
                iconURL: interaction.client.user.displayAvatarURL() 
            })
            .setTimestamp();

        await interaction.update({ 
            embeds: [processingEmbed], 
            components: [] // Remove all buttons immediately
        });

        const userId = interaction.user.id;

        // Perform atomic sale operation using MongoDB aggregation pipeline
        const saleResult = await performAtomicSaleAll(DataBase, userId);
        
        if (!saleResult.success) {
            const errorEmbed = new EmbedBuilder()
                .setTitle("‚ùå " + saleResult.title)
                .setColor("#FF4757")
                .setDescription(saleResult.message)
                .setFooter({ 
                    text: saleResult.footer, 
                    iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();
            
            return await interaction.editReply({ 
                embeds: [errorEmbed], 
                components: [] 
            });
        }

        // Apply XP bonus through ZiRank (10% of ZiGold earned as XP)
        const xpReward = Math.floor(saleResult.totalValue * 0.1);
        try {
            await ZiRank.execute({ 
                user: interaction.user, 
                XpADD: xpReward,
                CoinADD: 0 // We already handled coins in the atomic update
            });
        } catch (rankError) {
            console.error("ZiRank error in sell:", rankError);
            // Continue with sale success even if ZiRank fails
        }

        // Create success embed
        const successEmbed = new EmbedBuilder()
            .setTitle(`${sellEmoji} MASSIVE SALE COMPLETE! ${sparkleEmoji}`)
            .setColor("#4CAF50")
            .setThumbnail(interaction.user.displayAvatarURL({ dynamic: true }))
            .setDescription(`**üéâ CONGRATULATIONS!** You just sold your entire collection!\n\n**This was a HUGE sale!** ${gemEmoji}`)
            .addFields(
                {
                    name: `${sellEmoji} Total Sale`,
                    value: `ü¶Å **${saleResult.totalAnimals.toLocaleString()}** animals sold\n${zigoldEmoji} **+${saleResult.totalValue.toLocaleString()}** ZiGold earned`,
                    inline: true
                },
                {
                    name: `${starEmoji} Bonuses`,
                    value: `${starEmoji} **+${xpReward}** XP\nüèÜ **Collection Cleared!**`,
                    inline: true
                },
                {
                    name: `${sparkleEmoji} New Balance`,
                    value: `${zigoldEmoji} **${saleResult.newBalance.toLocaleString()}** ZiGold`,
                    inline: true
                }
            )
            .setFooter({ 
                text: `üéØ Time to start hunting again! ‚Ä¢ ZiBot Market`,
                iconURL: interaction.client.user.displayAvatarURL() 
            })
            .setTimestamp();

        // Add motivational message
        if (saleResult.totalValue >= 50000) {
            successEmbed.addFields({
                name: `${gemEmoji} ACHIEVEMENT UNLOCKED!`,
                value: `**üíé BIG SPENDER!** - Sold collection worth 50k+ ZiGold!`,
                inline: false
            });
        } else if (saleResult.totalValue >= 10000) {
            successEmbed.addFields({
                name: `${starEmoji} Great Sale!`,
                value: `**‚≠ê COLLECTOR!** - Impressive collection sale!`,
                inline: false
            });
        }

        await interaction.editReply({ embeds: [successEmbed] });

    } catch (error) {
        console.error("Error in confirm_sell_all:", error);
        await handleButtonError(interaction, error);
    }
};

// Atomic sale operation that prevents race conditions
async function performAtomicSaleAll(DataBase, userId) {
    try {
        // First, get current user data to compute sale value
        const userDB = await DataBase.ZiUser.findOne({ userID: userId });
        
        if (!userDB || !userDB.huntStats || Object.keys(userDB.huntStats).length === 0) {
            return {
                success: false,
                title: "Kh√¥ng c√≥ animals!",
                message: "B·∫°n kh√¥ng c√≤n animals n√†o ƒë·ªÉ b√°n!",
                footer: "Animals ƒë√£ ƒë∆∞·ª£c b√°n ho·∫∑c chuy·ªÉn ƒëi!"
            };
        }

        // Calculate what should be sold
        const huntStats = userDB.huntStats || {};
        let totalAnimals = 0;
        let totalValue = 0;
        const animalEntries = [];

        for (const [huntKey, huntData] of Object.entries(huntStats)) {
            if (!huntData || !huntData.count || huntData.count <= 0) continue;
            
            const parts = huntKey.split('_');
            const rarity = parts[0];
            const animalName = parts.slice(1).join('_');
            
            if (!animals[rarity]) continue;
            
            const animalData = animals[rarity].find(a => a.name === animalName);
            if (animalData) {
                const count = huntData.count;
                const value = animalData.value * count;
                
                totalAnimals += count;
                totalValue += value;
                animalEntries.push({
                    huntKey,
                    count,
                    value
                });
            }
        }

        if (totalAnimals === 0) {
            return {
                success: false,
                title: "Kh√¥ng c√≥ animals!",
                message: "B·∫°n kh√¥ng c√≤n animals n√†o ƒë·ªÉ b√°n!",
                footer: "Animals ƒë√£ ƒë∆∞·ª£c b√°n r·ªìi!"
            };
        }

        // Build atomic update operations - set all animal counts to 0
        const setOperations = {};
        for (const entry of animalEntries) {
            setOperations[`huntStats.${entry.huntKey}.count`] = 0;
        }

        // Add transaction tracking to prevent duplicate processing
        // Remove transactionId tracking since we're using simple IDs now

        // Build condition that ensures inventory hasn't changed since we calculated totals
        const inventoryConditions = { 
            userID: userId
        };
        
        // Add conditions to verify animal counts are still as expected
        for (const entry of animalEntries) {
            inventoryConditions[`huntStats.${entry.huntKey}.count`] = { $gte: entry.count };
        }

        // Perform atomic update - only proceed if inventory state matches expectations
        const updateResult = await DataBase.ZiUser.findOneAndUpdate(
            inventoryConditions,
            {
                $inc: {
                    coin: totalValue,
                    totalAnimals: -totalAnimals
                },
                $set: setOperations
            },
            { new: true }
        );

        if (!updateResult) {
            return {
                success: false,
                title: "Giao d·ªãch ƒë√£ x·ª≠ l√Ω!",
                message: "Giao d·ªãch n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω r·ªìi ho·∫∑c inventory ƒë√£ thay ƒë·ªïi!",
                footer: "Vui l√≤ng ki·ªÉm tra l·∫°i collection c·ªßa b·∫°n!"
            };
        }

        return {
            success: true,
            totalAnimals,
            totalValue,
            newBalance: updateResult.coin
        };

    } catch (error) {
        console.error("Atomic sale operation error:", error);
        return {
            success: false,
            title: "L·ªói h·ªá th·ªëng!",
            message: "C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω giao d·ªãch. Vui l√≤ng th·ª≠ l·∫°i!",
            footer: "N·∫øu v·∫•n ƒë·ªÅ ti·∫øp t·ª•c, h√£y li√™n h·ªá admin!"
        };
    }
}

async function handleInitializationError(interaction, isDatabaseError) {
    const errorEmbed = new EmbedBuilder()
        .setTitle(`‚ö†Ô∏è ${sparkleEmoji} Kh·ªüi t·∫°o h·ªá th·ªëng`)
        .setColor("#FFD700")
        .setDescription(
            isDatabaseError 
            ? `üîÑ **Database ƒëang kh·ªüi t·∫°o...**\n\n${sparkleEmoji} Vui l√≤ng ƒë·ª£i v√†i gi√¢y r·ªìi th·ª≠ l·∫°i!`
            : `üîÑ **H·ªá th·ªëng ZiRank ƒëang kh·ªüi t·∫°o...**\n\n${sparkleEmoji} Vui l√≤ng ƒë·ª£i v√†i gi√¢y r·ªìi th·ª≠ l·∫°i!`
        )
        .setFooter({ 
            text: "H·ªá th·ªëng s·∫Ω s·∫µn s√†ng trong gi√¢y l√°t!", 
            iconURL: interaction.client.user.displayAvatarURL() 
        })
        .setTimestamp();
    
    return await interaction.update({ 
        embeds: [errorEmbed], 
        components: [] 
    });
}

async function handleButtonError(interaction, error) {
    console.error("Confirm sell all button error:", error);
    const errorEmbed = new EmbedBuilder()
        .setTitle("‚ùå L·ªói")
        .setColor("#FF0000")
        .setDescription("C√≥ l·ªói x·∫£y ra khi b√°n animals. Vui l√≤ng th·ª≠ l·∫°i!");
    
    try {
        if (interaction.replied || interaction.deferred) {
            return await interaction.editReply({ embeds: [errorEmbed], components: [] });
        } else {
            return await interaction.update({ embeds: [errorEmbed], components: [] });
        }
    } catch (updateError) {
        console.error("Failed to update interaction after error:", updateError);
    }
}